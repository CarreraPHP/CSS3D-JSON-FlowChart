<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>Flow Chart</title>
		<link rel="stylesheet" href="css/demo.css" />
		<style>

		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/tween.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script src="js/CSS3DRenderer.js"></script>

		<div id="container"></div>
		<script>
			var camera, scene, renderer;
			var controls;

			var objects = [];
			var grid = [];

			var i=1, xArr = [0];
			for(; i <= 50; i++){xArr.push(i);xArr.push(-i);}
			var chart = [{
				name: 'User is getting slow response',
				description: '',
				options: [{
					name: 'Always',
					impact: -1,
					charts: [{
						name: 'Use APM Introscope to monitor the execution time for queries, heap size, etc',
						description: '',
						options: [{
							name: 'Check',
							impact: -1,
							charts: [{
								name: 'Check whether the utilization of the server is high',
								description: '',
								options: [{
									name: 'Always',
									impact: -1,
									charts: [{
										name: 'Check whether the Query is taking more time',
										description: '',
										options: [{
											name: 'Always',
											impact: -1,
											charts: [{
												name: 'Try with different login id\'s and see if for all users getting slow response',
												description: '',
												options: [{
													name: 'Finish',
													charts: []
												}]
											}]
										}]
									}]
								}]
							}]
						}, {
							name: 'Always',
							charts: [{
								name: 'Nothing Here',
								description: '',
								options: [{
									name: 'finish',
									charts: []
								}]
							}]
						}]
					}]
				}]
			}];

			function createOptHolder(){
				var details = document.createElement( 'div' );
				details.className = 'details';
				return details;
			}

			function createOptSiblings(optHolder, content){
				var options = document.createElement('div');
				options.innerHTML = content;
				optHolder.appendChild(options);
			}

			function createCard(content){
				var element = document.createElement( 'div' );
				element.className = 'element';
// 				element.style.backgroundColor = 'rgba(0,127,127,' + ( Math.random() * 0.2 + 0.25 ) + ')';
				element.style.backgroundColor = 'rgba(250,250,250,' + ( Math.random() * 0.08 ) + ')';

				var symbol = document.createElement( 'div' );
				symbol.className = 'symbol';
				symbol.textContent = content;
				element.appendChild( symbol );

				return element;
			}

			function parseChartOptions(opts){
				var optHolder = createOptHolder();
				for(var z in opts){
					console.log("options : ", z, opts[z]);
					var opt = opts[z];
					if(opt.charts.length > 0){
						parserChartList(opt.charts);
					}
					createOptSiblings(optHolder, opt.name);
				}
				return optHolder;
			}

			function parserChartList(lists, z_index){
				for(var z in lists){
					var lt = lists[z];
					var ltCard = createCard(lt.name);
					console.log("chart : ", z, lt, lt.options);
					if(lt.options.length > 0){
						ltCard.appendChild(parseChartOptions(lt.options));
					}

					var object = new THREE.CSS3DObject( ltCard );
					object.position.x = 0; //Math.random() * 4000 - 2000;
					object.position.y = 0; //Math.random() * 4000 - 2000;
					object.position.z = z_index || 0; //Math.random() * 4000 - 2000;
					scene.add( object );

					objects.push( object );
				}
			}

			init();

			animate();

			function init() {

				window.camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 3000;

				scene = new THREE.Scene();

				parserChartList(chart, 0);

				// grid
				for ( var i = objects.length-1; i >= 0; i-- ) {
					var object = new THREE.Object3D();

					object.position.x = ( ( i % 3 ) * 400 ) - 0;
					console.log(object.position.x);
					object.position.y = 0; //( - ( Math.floor( i / 5 ) % 5 ) * 400 ) + 800;
					object.position.z = ( Math.floor( (i) / 1 ) ) * 1000 - 2000; //objects.length -

					grid.push( object );
				}

				renderer = new THREE.CSS3DRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.domElement.style.position = 'absolute';
				document.getElementById( 'container' ).appendChild( renderer.domElement );

				controls = new THREE.TrackballControls( camera, renderer.domElement );
				controls.rotateSpeed = 0.5;
				controls.minDistance = 0;
				controls.maxDistance = 10000;
				controls.addEventListener( 'change', render );

				transform(grid, 2000 );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function transform( targets, duration ) {

				TWEEN.removeAll();

				for ( var i = 0; i < objects.length; i ++ ) {

					var object = objects[ i ];
					var target = targets[ i ];

					new TWEEN.Tween( object.position )
						.to( { x: target.position.x, y: target.position.y, z: target.position.z }, Math.random() * duration + duration )
						.easing( TWEEN.Easing.Exponential.InOut )
						.start();

					new TWEEN.Tween( object.rotation )
						.to( { x: target.rotation.x, y: target.rotation.y, z: target.rotation.z }, Math.random() * duration + duration )
						.easing( TWEEN.Easing.Exponential.InOut )
						.start();

				}

				new TWEEN.Tween( this )
					.to( {}, duration * 2 )
					.onUpdate( render )
					.start();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

			function animate() {

				requestAnimationFrame( animate );

				TWEEN.update();

				controls.update();

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
